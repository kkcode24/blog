# smarty

## smarty的思想
> 把标签解析成php输出语句，即是模板文件到php文件的过程。

## smarty之辩

- smarty编译模板浪费时间
- 在把变量重新赋值到对象的属性上，增大了开销
- 多引入了Smarty这个类

## Smarty之简单实现

```php

class miniSmarty {
	public $template_dir = ''; //模板文件所在的目录
	public $complete_dir = ''; //编译后文件所在目录

	// 定义一个数组，用来接收外部的变量
	public $_tpl_var = array();

	public function compile($template){
		$tempFile = $this->$template_dir . '/' . $template;
		// 读取模板文件内容
		$source = file_get_contents($tempFile);

		// 判断编译文件是否存在且模板文件修改时间小于编译后的文件的修改时间=》不用再次编译
		if(file_exists($compFile) && filemtime($tempFile)<filemtime($compFile)){
			return $compFile;
		}

		// 替换模板内容
		$source = str_replace('{$','<?php echo $this->_tpl_var[\'',$source);
		$source = str_replace('}','\'];?>',$source);

		// 再把编译后的文件保存成php文件
		$compFile = $this->$complete_dir . '/' . $template . '.php';
		file_put_contents($compFile,$source);

		return $compFile;
	}

	public fucntion assign($key,$value){
		$this->_tpl_var[$key] = $value;
	}

	public function display($template){
		$compileFile = $this->compile($template);
		include($compileFile);
	}
}

```

## smarty的工作流程

1. 把需要显示的全局变量，塞到对象内部的属性上，一个数组里
2. 编译模板即把{$标签}解析成相应的php代码
3. 引入编译后的php文件

## 使用Smarty的步骤

1. Smarty是一个类，先引入并实例化
2. 配置：模板目录和编译目录...
3. assign赋值
4. 调用display方法，并把模板文件当参数传入进去

```php
①引入smarty
require('../smarty3/smaty.class.php');
②实例化
$smarty = new Smarty();
③配置
$smarty->template_dir('../template');
$smarty->complete_dir('../complete');
④赋值
$smarty->assign('language','php');
$smarty->assign('frame','smarty3');
⑤编译模板并引入
$smarty->display('technology.html');

```

> 待编译模板文件technology.html

```html
<!DOCTYPE html>
<html>
<head>
	<title>{$frame}</title>
</head>
<body>
	{$language}
</body>
</html>
```

> 编译后的文件technology.php

```php
<!DOCTYPE html>
<html>
<head>
	<title><?php echo $this->_tpl_var['frame']; ?></title>
</head>
<body>
	<?php echo $this->_tpl_var['language']; ?>
</body>
</html>
```

## smarty对象的赋值和引用

1. smarty能赋值数组，能否赋值对象呢？
2. 我们总是反复配置Smarty模板的template_dir等选项，能否简化？
3. 模板里用标签引用一个变量，还能否进行修改？
4. php中能分支，循环输出，模板中能不能？

```php
①引入smarty
require('../smarty3/smaty.class.php');
②实例化
$smarty = new Smarty();
③配置
$smarty->template_dir('../template');
$smarty->complete_dir('../complete');

class human {
	public $name = '张三';
	public $age = '25';
	
	public function say(){
		return 'hello world';
	}
}

$man = new human();

$smarty->assign('man',$man);

$smarty->display('object.html');

```

> object.html

```html
<!DOCTYPE html>
<html>
<head>
	<title>对象的引用是$标签->属性</title>
</head>
<body>
	<h2>{$man->name}</h2>
	<h2>{$man->age}</h2>

	<h1>调用对象的方法使用$标签->method();</h1>
	<p>{$man->name}说：{$man->say()}</p>

	所以，模板中的标签，应尽量只负责变量的 输出。
	就是负责显示数据的，不用负责太多的逻辑判断，函数调用等。
	所以，不推荐在模板中做逻辑判断及函数调用等。

</body>
</html>
```

## 通过继承来简化模板配置

```php 

// mySmarty.class.php

class MySmarty extend Smarty {

	// template_dir 和compile_dir 是父类的私有属性
	// 因此，无法复写，但是可以利用开放的接口来实现。
	public function __construct(){
		parent::__construct();

		$this->setTemplateDir('./template');
		$this->setCompileDir('./compile');
	}

}


```

* 再次使用Smarty

```php 

require('../smarty3/smaty.class.php');
require('../mySmaty.class.php');

$smarty = new MySmarty();

class human {
	public $name = '张三';
	public $age = '25';
	
	public function say(){
		return 'hello world';
	}
}

$man = new human();
$smarty->assign('man',$man);
$smarty->display('object.html');

```
